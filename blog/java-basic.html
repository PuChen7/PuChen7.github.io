<!-- This is the About Me page -->
<!DOCTYPE html>
<html>
    <head>
        <title>Pu Chen | Blog</title>

        <!-- CSS links -->
        <link rel="stylesheet" href="../css/blog.css" />
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script>
            $(document).ready(function(){
                
                // Add smooth scrolling to all links
                $("a").on('click', function(event) {
                    // Make sure this.hash has a value before overriding default behavior
                    if (this.hash !== "") {
                        // Prevent default anchor click behavior
                        event.preventDefault();
                
                        // Store hash
                        var hash = this.hash;
                
                        // Using jQuery's animate() method to add smooth page scroll
                        // The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
                        $('html, body').animate({
                        scrollTop: $(this.hash).offset().top - ($('#nav-bar').height()+10)
                        }, 800, function(){
                    
                        // Add hash (#) to URL when done scrolling (default click behavior)
                        window.location.hash = hash;
                        
                        });
                    } // End if
                });
            });        
            
            
        </script>
    </head>

    <body>
        <!-- Navigation Bar -->
        <nav id="nav-bar">
            <div class="tag">Core Java | Pu Chen</div>
            <ul>
                <li><a href="../contact.html">Contact</a></li>
                <li><a href="../archives.html">Archives</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
                <li><a href="https://github.com/PuChen7">Projects</a></li>
                <li><a class="active" href="../index.html">Home</a></li>
            </ul>
        </nav>

        <div id="guide"><h><b>Topics Covered in this Page</b></h>
            <ol>
                <li><a href="#java-key-words-sec">Java Key Words</a></li>
                <li><a href="#access-modifiers-sec">Access Modifiers</a></li>
                <li><a href="#wrapper-class-sec">Wrapper Class</a></li>
                <li><a href="#exception-sec">Exception</a></li>
            </ol>
        </div>
       <!-- Main body of the front page -->
       <div class="blog-content">
            <h><span id="java-key-words-sec"Java Key Words></span>Java Key Words</h>
            <ul>
                <li><text><b>final</b></text>:
                    <ul>
                        <li><text>Final Class</text> cannot be subclassed</li>
                        <li><text>Final methods</text> cannot be overridden</li>
                        <li><text>Final variables</text> can occur at most once as a left-hand expression on an executed command</li>
                        <li>All methods in a final class are implicitly <text>final</text></li>
                    </ul>
                </li>

                <li><text><b>finally</b></text>
                    <ul>
                        <li><text>Finally block</text> in java can be used to put "cleanup" code such as closing a file, closing connection etc.</li>
                        <li>Java <text>finally block</text> is always executed whether exception is handled or not.</li>
                        <li>This is used to close non-memory resources like file handles, sockets, database connections</li>
                    </ul>
                </li>

                <li><text><b>static</b></text>
                    <ul>
                        <li><text>static</text> members belong to the class instead of a specific instance.</li>
                    </ul>
                </li>
            </ul>

            <h id="access-modifiers-sec">Access Modifiers</h>
            <ul>
                <li> <text><b>default</b></text>: Visible to the package. No modifiers are needed.
                    <ul>
                        <li>A variable or method declared without any access control modifier is available to any other class in the same package.</li>
                    </ul>
                </li>
                <li><text><b>private</b></text>: Visible to the class only
                    <ul>
                        <li>Methods, variables, and constructors that are declared <text>private</text> can only be accessed within the declared class itself.</li>
                        <li><text>Private access modifier</text> is the most restrictive access level. Class and interfaces cannot be private.</li>
                    </ul>
                </li>
                <li><text><b>public</b></text>: Visible to the world
                    <ul>
                        <li>A class, method, constructor, interface, etc. declared <text>public</text> can be accessed from any other class.</li>
                    </ul>
                </li>
                <li><text><b>protected</b></text>: Visible to the package and all subclasses
                    <ul>
                        <li>Variables, methods, and constructors, which are declared <text>protected</text> in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.</li>
                        <li>The protected access modifier cannot be applied to class and interfaces. </li>
                    </ul>
                </li>
            </ul>

            <img src="../img/access-modifiers.jpg" style="width:60%;height:60%;"><br>

            <br>

            <h id="wrapper-class-sec">Wrapper Class</h><br>
            Wrapper classes are used to convert any data type into an object.
            <ul>
                <li><text><b>Autoboxing</b></text>: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing.</li>
                <li><text><b>Unboxing</b></text>: Automatically converting an object of a wrapper class to its corresponding primitive type is known as unboxing. </li>
            </ul>

            <br>

            <h>Generics</h><br>
            Generics was added in Java 5 to provide compile-time type checking 
            and removing risk of ClassCastException that was common while working with collection classes.<br>
            It provides compile time type-safety and ensures that you only insert correct Type in collection and avoids ClassCastException in runtime.<br>
            <b>Example:</b><br>
            <pre class="prettyprint">
                List<String> list = new ArrayList<String>();
                list.add("1");
                list.add("string");
                String str = list.get(1);
                System.out.println(str);    // output: string
            </pre>
            <b>Generics for loop:</b><br>
            <pre class="prettyprint">
                List<String> strings = new ArrayList<String>();
                //... add String instances to the strings list...      
                for(String aString : strings){
                    System.out.println(aString);
                }
            </pre>

            <br>

            <h>Comparable and Comparator</h><br>
            <text><b>Comparable</b></text> and <text><b>Comparator</b></text> both are interfaces and can be used to sort collection elements.
            It provide <text><b>single sorting sequence</b></text> only.<br><br>
            
            <b>Comparable Interface</b><br>
            Method: <text><b>compareTo(Object)</b></text>: used to compare the current object with the specified object.<br>
            It compares strings on the basis of <text><b>Unicode value</b></text> of each character in the strings.<br>
            return: >: positive int / ==: 0 / <: negative int<br>
            <br>
            Can used to sort:
            <ul>
                <li>String objects</li>
                <li>Wrapper class objects</li>
                <li>User-defined class objects</li>
            </ul>

            <b>Comparator Interface</b><br>
            Used to order the objects of user-defined class. It provides <text><b>multiple</b></text> sorting sequence <br>
            Method: <text><b>compare(Object obj1,Object obj2)</b></text> and <text><b>equals(Object element)</b></text>.

            <br>

            <b>When to use Comparable and Comparator</b><br>
            <mark>Comparable</mark>: when sorting based on natural order.<br>
            <mark>Comparator</mark>: when sorting based on special ordering.<br>

            <br>

            <h>Garbage Collector</h><br>
            <ul>
                <li>Not to care for all those objects which are no longer in use. <text>Garbage collector</text> destroys these objects.</li>
                <li>Garbage collector is best example of <text>Daemon thread</text> as it is always running in background.</li>
                <li>Main objective of Garbage Collector is to free <text>heap memory</text> by destroying unreachable objects.</li>
                <li>Eligibility for garbage collection:
                    <ul>
                        <li><text>Unreachable objects</text> : An object is said to be unreachable iff it doesn't contain any reference to it.</li>
                        <li>Object created inside method</li>
                        <li>Nullifying the reference variable</li>
                    </ul>
                </li>
            </ul>

            <h>Java Compile-time Vs Run-time</h><br>
            <text><b>Compile-time</b></text> is the instance where the code you entered is converted to executable while <text><b>Run-time</b></text> is the instance where the executable is running.<br><br>
            <b>What could happen at <text>Compile time</text></b>?<br>
            <ul>
                <li>Syntax Errors</li>
                <li>Typechecking errors</li>
            </ul>

            <b>What could happen at <text>Run time</text></b>?<br>
            <ul>
                <li>Running out of memory</li>
                <li>Division by zero</li>
                <li>Trying to open a file that isn't there</li>
            </ul>

            <br><img src="../img/run-compile-time.jpg" style="width:40%;height:40%;"><br>

            <h>How Java works</h><br>
            <ul>
                <li>Source file(.java)</li>
                <li>run source file through <text><b>Java Compiler (javac)</b></text>. It checks for error and syntax in the source file. 
                    It transforms source file into <text><b>bytecode</b></text>. The bytecode is platform independent, 
                    because it's targeted at Java Virtual Machine.</li>
                <li>Compiler creates <text><b>classfile</b></text>. This classfile is coded into bytecode. The classfile is <text><b>portable</b></text> and can be ran on any platform.</li>
                <li><text><b>Java Virtual Machine</b></text> runs the classfile. It is a specification that provides <text><b>run-time environment</b></text> in which java bytecode can be executed.</li>
                <li><text><b>Java Runtime Environment (JRE) </b></text>refers to a runtime environment in which java bytecode can be executed. It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that JVM uses at runtime.</li>
                <li><text><b>Java Development Kit (JDK) </b></text>a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (java), a compiler (javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development.</li>
            </ul>
            <b>In general</b><br>
            <ul>
                <li><mark><b>JDK</b></mark>: provides the environment to Develop and execute(run ) the Java program. (Development tools, and JRE)</li>
                <li><mark><b>JRE</b></mark>: provides environment to only run(not develop) the java program. JRE is only used by them who only wants to run the Java Programs i.e. end users of your system. Contains built in libraries, JVM, toolkits.</li>
                <li><mark><b>JVM</b></mark>: contained in both JRE and JDK. JVM is responsible for executing the java program line by line. Also known as <mark>interpreter</mark></li>
            </ul>

            <h>Class loader</h><br>
            The Java Class loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.<br>

            <br>

            <h id="exception-sec">Exceptions</h><br>
            Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.<br>
            <br><img src="../img/exception.jpg" style="width:40%;height:40%;"><br>
            <br>
            <b>Error vs Exception</b><br>
            <text>Error</text>: An Error indicates serious problem that a application should not try to catch. It is impossible to recovery.<br>
            <text>Exception</text>: Exception indicates conditions that a application might try to catch.<br>
            <br>
            <b>How JVM handles exceptions</b><br>
            <ul>
                <li>If an exception has occurred, the method creates an Object known as <text><b>Exception Object</b></text> and hands it off to the JVM. (<text>throwing an Exception</text>)</li>
                <li>The exception object contains <text>name</text> and <text>description</text> of the exception, and <text>current state</text> of the program where exception has occurred.</li>
                <li>There might be the list of the methods that had been called to get to the method where exception was occurred. This ordered list of the methods is called <text><b>Call Stack</b></text>.</li>
                <li>The run-time system searches the call stack to find <text><b>Exception Handler.</b></text>
                    <ul>
                        <li>If found: run-time system pass exception to the handler</li>
                        <li>If not found: run-time system handover the Exception Object to <text>default exception handler</text>.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Types of Exception</b><br>
            <ul>
                <li>Checked Exception
                    <ul>
                        <li>All exceptions other than <text><b>Runtime Exceptions</b></text> are known as Checked exceptions as the 
                            compiler checks them during compilation to see whether the programmer has handled them or not.
                            e.g.IOException, SQLException etc.</li>
                    </ul>
                </li>
                <li>Unchecked Exception
                    <ul>
                        <li>Runtime Exceptions are also known as Unchecked Exceptions. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Throw vs Throws</b>
            <ul>
                <li>Throw
                    <ul>
                        <li>The throw keyword in Java is used to explicitly throw an exception from a method or any block of code. We can throw either checked or unchecked exception.</li>
                    </ul>
                </li>
                <li>Throws
                    <ul>
                        <li>throws keyword is required only for <text><b>checked exception</b></text> and usage of throws keyword for unchecked exception is meaningless.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <h><code>java.lang</code> and <code>java.util</code></h><br>
            <code><b>Java.lang</b></code> is a package which contains the classes like 
            System, String, String Buffer etc., This package doesn't 
            have to be explicitly imported as they are imported by 
            default.<br>
            <code><b>java.util</b></code> is a package which contains classes like 
            Date, Vector, Dictionary, hashtable etc., This has to be 
            imported everytime you use it in your program<br>

            <br>

            <h>Memory Model</h><br>
            <b>Stack</b>: Stack memory is responsible for holding references to heap objects and for storing value types. 
            Thread has its own stack. Only exist within the scope of the function, once return, they are destroyed.<br>
            <b>Heap</b>: referenced by stack. Objects are created on heap.<br>
            
            <br>
            
            <h>Array Copy</h><br>
            <ul>Ways to achieve array copy:
                <li><text>Object.clone()</text>: provided by Object class</li>
                <li><text>System.arraycopy()</text>: provided by System class</li>
                <li><text>Arrays.copyOf()</text></li>
                <li><text>Arrays.copyOfRange()</text>: uses System.arraycopy() method itself</li>
            </ul>

            <h>Serialization</h><br>
            <mark>Serialization</mark> is a mechanism of converting the state of an object into a <text>byte stream</text>.<br>
            <mark>Deserialization</mark> is the reverse process where the byte stream is used to recreate the actual Java object in memory.<br>
            <ul>
                <li>If you want a class object to be <text>serializable</text>, all you need to do it implement the <mark>java.io.Serializable</mark> interface.</li>
                <li>Serialization in java is implemented by <mark>ObjectInputStream</mark> and <mark>ObjectOutputStream</mark>.</li>
            </ul>

            <b>Example:</b><br>
            Example of Serialize to a file and Deserialize from the same file.
        
            <pre class="prettyprint">
                import java.io.FileInputStream;
                import java.io.FileOutputStream;
                import java.io.IOException;
                import java.io.ObjectInputStream;
                import java.io.ObjectOutputStream;

                public class SerializationUtil {
                    // deserialize to Object from given file
                    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
                        FileInputStream fis = new FileInputStream(fileName);
                        ObjectInputStream ois = new ObjectInputStream(fis);
                        Object obj = ois.readObject();
                        ois.close();
                        return obj;
                    }

                    // serialize the given object and save it to file
                    public static void serialize(Object obj, String fileName) throws IOException {
                        FileOutputStream fos = new FileOutputStream(fileName);
                        ObjectOutputStream oos = new ObjectOutputStream(fos);
                        oos.writeObject(obj);
                        fos.close();
                    }
                }
            </pre>

            <pre class="prettyprint">
                import java.io.IOException;

                public class SerializationTest {
                    
                    public static void main(String[] args) {
                        String fileName="employee.ser";
                        Employee emp = new Employee();
                        emp.setId(100);
                        emp.setName("Pankaj");
                        emp.setSalary(5000);
                        
                        //serialize to file
                        try {
                            SerializationUtil.serialize(emp, fileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                            return;
                        }
                        
                        Employee empNew = null;
                        try {
                            empNew = (Employee) SerializationUtil.deserialize(fileName);
                        } catch (ClassNotFoundException | IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            </pre>
            <br>

            <ul><b>Serialization Methods</b>
                <li><text>readObject(ObjectInputStream ois)</text>: If this method is present in the class, ObjectInputStream readObject() method will use this method for reading the object from stream.</li>
                <li><text>writeObject(ObjectOutputStream oos)</text>: If this method is present in the class, ObjectOutputStream writeObject() method will use this method for writing the object to stream. </li>
                <li><text>Object writeReplace()</text>: If this method is present, then after serialization process this method is called and the object returned is serialized to the stream.</li>
                <li><text>Object readResolve()</text>: If this method is present, then after deserialization process, this method is called to return the final object to the caller program.</li>
            </ul>

            <ul><b>Serialization with Inheritance</b>
                <li><b><text>Case 1</text>: If superclass is serializable then subclass is automatically serializable</b>
                    <ul>
                        <li>If superclass is Serializable, then by default every subclass is serializable.</li>
                    </ul>
                </li>
                <li><b><text>Case 2</text>: If a superclass is not serializable then subclass can still be serialized</b>
                    <ul>
                        <li>Even though superclass doesn't implements Serializable interface, we can serialize subclass object if subclass itself implements Serializable interface.</li>
                    </ul>
                </li>
                <li><b><text>Case 3</text>: If the superclass is serializable but we don't want the subclass to be serialized</b>
                    <ul>
                        <li>One possible way by which a programmer can achieve this is by implementing the <mark>writeObject()</mark> and <mark>readObject()</mark> methods in the subclass and needs to throw NotSerializableException from these methods.</li>
                    </ul>
                </li>
            </ul>

            <b><text>transient</text> keyword in Java</b><br>
            <ul>
                <li>If we don't want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.</li>
                <li>transient keyword plays an important role to meet security constraints. There are various real-life examples where we don't want to save private data in file. </li>
            </ul>

            <h>Java Multithreading</h><br>
            <b>Life Cycle of a Thread</b><br>
            <img src="../img/Thread_Life_Cycle.jpg" style="width:40%;height:40%;"><br>
            <ul>
                <li><text>New</text>: A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread.</li>
                <li><text>Runnable</text>: After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.</li>
                <li><text>Waiting</text>: Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task. A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.</li>
                <li><text>Timed Waiting</text>: A runnable thread can enter the timed waiting state for a specified interval of time.</li>
                <li><text>Terminated</text>: A runnable thread enters the terminated state when it completes its task or otherwise terminates.</li>
            </ul>


            <ul><b>Thread creation by extending the Thread class</b>
                <li>Create a class that extends the java.lang.Thread class</li>
                <li>This class overrides the <text>run()</text> method available in the <text>Thread</text> class.</li>
                <li> A thread begins its life inside <text>run()</text> method. We create an object of our new class and call <text>start()</text> method to start the execution of a thread.</li>
                <li>Start() invokes the run() method on the Thread object.</li>
            </ul>

            <pre class="prettyprint">
                    // Java code for thread creation by extending the Thread class 
                    class MultithreadingDemo extends Thread { 
                        public void run() { 
                            try { 
                                // Displaying the thread that is running 
                                System.out.println ("Thread " + Thread.currentThread().getId() + " is running"); 
                      
                            } 
                            catch (Exception e) { 
                                // Throwing an exception 
                                System.out.println ("Exception is caught"); 
                            } 
                        } 
                    } 
                      
                    // Main Class 
                    public class Multithread { 
                        public static void main(String[] args) { 
                            int n = 8; // Number of threads 
                            for (int i=0; i<8; i++) { 
                                MultithreadingDemo object = new MultithreadingDemo(); 
                                object.start(); 
                            } 
                        } 
                    } 

                    /* Output
                    Thread 8 is running
                    Thread 9 is running
                    Thread 10 is running
                    Thread 11 is running
                    Thread 12 is running
                    Thread 13 is running
                    Thread 14 is running
                    Thread 15 is running */
            </pre>

            <ul><b>Thread creation by implementing the Runnable Interface</b>
                <li>Create a new class which implements <text>java.lang.Runnable</text> interface and <text>override run()</text>> method.</li>
                <li>Then instantiate a <text>Thread object</text> and call <text>start()</text> method on this object.</li>
            </ul>
            <pre class="prettyprint">
                    // Java code for thread creation by implementing the Runnable Interface 
                    class MultithreadingDemo implements Runnable { 
                        public void run() { 
                            try { 
                                // Displaying the thread that is running 
                                System.out.println ("Thread " + Thread.currentThread().getId() + " is running"); 
                      
                            } 
                            catch (Exception e) { 
                                // Throwing an exception 
                                System.out.println ("Exception is caught"); 
                            } 
                        } 
                    } 
                      
                    // Main Class 
                    class Multithread { 
                        public static void main(String[] args) { 
                            int n = 8; // Number of threads 
                            for (int i=0; i<8; i++) { 
                                Thread object = new Thread(new MultithreadingDemo()); 
                                object.start(); 
                            } 
                        } 
                    } 
            </pre>

            <ul><b>Thread Class vs Runnable Interface</b>
                <li>If we extend the <text>Thread class</text>, our class cannot extend any other class because Java doesn't support <text>multiple</text> inheritance. But, if we implement the <text>Runnable interface</text>, our class can still extend other base classes.</li>
                <li>We can achieve basic functionality of a thread by extending <text>Thread class</text> because it provides some inbuilt methods like yield(), interrupt() etc. that are not available in <text>Runnable interface</text>.</li>
            </ul>
            
            <ul><b>join()</b>
                <li>If <mark>t</mark> is a Thread object whose thread is currently executing, then <mark>t.join();</mark> it causes the current thread to pause its execution until <mark>thread t</mark> completes its execution.</li>
                <li>overloaded join()
                    <ul>
                        <li>public final void join()</li>
                        <li>public final synchronized void join(long millis)</li>
                        <li>public final synchronized void join(long millis, int nanos)</li>
                    </ul>
                </li>
            </ul>

            <ul><b>Synchronized</b>
                <li>Why use: situation where multiple threads try to access the same resources</li>
                <li>Using synchronized blocks: All synchronized blocks synchronized on the same object can only have <mark>one thread</mark> executing inside them at a time.</li>
            </ul>
            <pre class="prettyprint">
                    // Only one thread can execute at a time. 
                    // sync_object is a reference to an object
                    // whose lock associates with the monitor. 
                    // The code is said to be synchronized on
                    // the monitor object
                    synchronized(sync_object) {
                       // Access shared variables and other
                       // shared resources
                    }
            </pre>

            <ul><b>Interthread Communication</b>
                <li>Why use: when threads need to exchange information</li>
                <li>Methods:
                    <ul>
                        <li><text>public void wait()</text>: Causes the <mark>current thread</mark> to wait until another thread invokes the <mark>notify()</mark>.</li>
                        <li><text>public void notify()</text>: Wakes up a single thread that is waiting on this object's monitor.</li>
                        <li><text>public void notifyAll()</text>: Wakes up all the threads that called wait( ) on the same object.</li>
                        <li>All three methods can be called only from within a <text>synchronized</text> context</li>
                    </ul>
                </li>
            </ul>

            <ul><b>Deadlock</b>
                <li>Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.</li>
                <li>Deadlock occurs when multiple threads need the same locks but obtain them in different order.</li>
                <li>Avoid:
                    <ul>
                        <li>Avoid Nested Locks</li>
                        <li>Avoid Unnecessary Locks</li>
                        <li>Using thread join</li>
                    </ul>
                </li>
            </ul>
       </div>
       
    </body>
</html>
