<!-- This is the About Me page -->
<!DOCTYPE html>
<html>
    <head>
        <title>Pu Chen | Blog</title>

        <!-- CSS links -->
        <link rel="stylesheet" href="../css/blog.css" />
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="../js/page-scroll.js"></script>
    </head>

    <body>
        <!-- Navigation Bar -->
        <nav id="nav-bar">
            <div class="tag">Core Java | Pu Chen</div>
            <ul>
                <li><a href="../contact.html">Contact</a></li>
                <li><a href="../archives.html">Archives</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
                <li><a href="https://github.com/PuChen7">Projects</a></li>
                <li><a class="active" href="../index.html">Home</a></li>
            </ul>
        </nav>

        <div id="guide"><h><b>Topics Covered in this Page</b></h>
            <ol>
                <li><a href="#java-key-words-sec">Java Key Words</a></li>
                <li><a href="#access-modifiers-sec">Access Modifiers</a></li>
                <li><a href="#wrapper-class-sec">Wrapper Class</a></li>
                <li><a href="#generics-sec">Generics</a></li>
                <li><a href="#comparable-sec">Comparable and Comparator</a></li>
                <li><a href="#garbage-sec">Garbage Collection</a></li>
                <li><a href="#compile-sec">Java Compile-time Vs Run-time</a></li>
                <li><a href="#work-sec">How java works</a></li>
                <li><a href="#class-loader-sec">Class Loader</a></li>
                <li><a href="#exception-sec">Exceptions</a></li>
                <li><a href="#lang-sec">java.lang and java.util</a></li>
                <li><a href="#mem-model-sec">Memory Model</a></li>
                <li><a href="#array-copy-sec">Array Copy</a></li>
                <li><a href="#serial-sec">Serialization</a></li>
                <li><a href="#multi-sec">Java Multithreading</a></li>
            </ol>
        </div>
       <!-- Main body of the front page -->
       <div class="blog-content">
            <h id="java-key-words-sec">Java Key Words</h>
            <ul>
                <li><text><b>final</b></text>:
                    <ul>
                        <li><text>Final Class</text> cannot be subclassed</li>
                        <li><text>Final methods</text> cannot be overridden</li>
                        <li><text>Final variables</text> can occur at most once as a left-hand expression on an executed command</li>
                        <li>All methods in a final class are implicitly <text>final</text></li>
                    </ul>
                </li>

                <li><text><b>finally</b></text>
                    <ul>
                        <li><text>Finally block</text> in java can be used to put "cleanup" code such as closing a file, closing connection etc.</li>
                        <li>Java <text>finally block</text> is always executed whether exception is handled or not.</li>
                        <li>This is used to close non-memory resources like file handles, sockets, database connections</li>
                    </ul>
                </li>

                <li><text><b>static</b></text>
                    <ul>
                        <li><text>static</text> members belong to the class instead of a specific instance.</li>
                    </ul>
                </li>
            </ul>

            <h id="access-modifiers-sec">Access Modifiers</h>
            <ul>
                <li> <text><b>default</b></text>: Visible to the package. No modifiers are needed.
                    <ul>
                        <li>A variable or method declared without any access control modifier is available to any other class in the same package.</li>
                    </ul>
                </li>
                <li><text><b>private</b></text>: Visible to the class only
                    <ul>
                        <li>Methods, variables, and constructors that are declared <text>private</text> can only be accessed within the declared class itself.</li>
                        <li><text>Private access modifier</text> is the most restrictive access level. Class and interfaces cannot be private.</li>
                    </ul>
                </li>
                <li><text><b>public</b></text>: Visible to the world
                    <ul>
                        <li>A class, method, constructor, interface, etc. declared <text>public</text> can be accessed from any other class.</li>
                    </ul>
                </li>
                <li><text><b>protected</b></text>: Visible to the package and all subclasses
                    <ul>
                        <li>Variables, methods, and constructors, which are declared <text>protected</text> in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.</li>
                        <li>The protected access modifier cannot be applied to class and interfaces. </li>
                    </ul>
                </li>
            </ul>

            <img src="../img/access-modifiers.jpg" style="width:60%;height:60%;"><br>

            <br>

            <h id="wrapper-class-sec">Wrapper Class</h><br>
            Wrapper classes are used to convert any data type into an object.
            <ul>
                <li><text><b>Autoboxing</b></text>: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing.</li>
                <li><text><b>Unboxing</b></text>: Automatically converting an object of a wrapper class to its corresponding primitive type is known as unboxing. </li>
            </ul>

            <br>

            <h id="generics-sec">Generics</h><br>
            Generics was added in Java 5 to provide compile-time type checking 
            and removing risk of ClassCastException that was common while working with collection classes.<br>
            It provides compile time type-safety and ensures that you only insert correct Type in collection and avoids ClassCastException in runtime.<br>
            <b>Example:</b><br>
            <pre class="prettyprint">
                List<String> list = new ArrayList<String>();
                list.add("1");
                list.add("string");
                String str = list.get(1);
                System.out.println(str);    // output: string
            </pre>
            <b>Generics for loop:</b><br>
            <pre class="prettyprint">
                List<String> strings = new ArrayList<String>();
                //... add String instances to the strings list...      
                for(String aString : strings){
                    System.out.println(aString);
                }
            </pre>

            <br>

            <h id="comparable-sec">Comparable and Comparator</h><br>
            <text><b>Comparable</b></text> and <text><b>Comparator</b></text> both are interfaces and can be used to sort collection elements.
            It provide <text><b>single sorting sequence</b></text> only.<br><br>
            
            <b>Comparable Interface</b><br>
            Method: <text><b>compareTo(Object)</b></text>: used to compare the current object with the specified object.<br>
            It compares strings on the basis of <text><b>Unicode value</b></text> of each character in the strings.<br>
            return: >: positive int / ==: 0 / <: negative int<br>
            <br>
            Can used to sort:
            <ul>
                <li>String objects</li>
                <li>Wrapper class objects</li>
                <li>User-defined class objects</li>
            </ul>

            <b>Comparator Interface</b><br>
            Used to order the objects of user-defined class. It provides <text><b>multiple</b></text> sorting sequence <br>
            Method: <text><b>compare(Object obj1,Object obj2)</b></text> and <text><b>equals(Object element)</b></text>.

            <br>

            <b>When to use Comparable and Comparator</b><br>
            <mark>Comparable</mark>: when sorting based on natural order.<br>
            <mark>Comparator</mark>: when sorting based on special ordering.<br>

            <br>

            <h id="garbage-sec">Garbage Collection</h><br>
            <ul>
                <li>Not to care for all those objects which are no longer in use. <text>Garbage collector</text> destroys these objects.</li>
                <li>Garbage collector is best example of <text>Daemon thread</text> as it is always running in background.</li>
                <li>Main objective of Garbage Collector is to free <text>heap memory</text> by destroying unreachable objects.</li>
                <li>Eligibility for garbage collection:
                    <ul>
                        <li><text>Unreachable objects</text> : An object is said to be unreachable iff it doesn't contain any reference to it.</li>
                        <li>Object created inside method</li>
                        <li>Nullifying the reference variable</li>
                    </ul>
                </li>
            </ul>
            <!-- ****************************************************************** -->
            <h id="compile-sec">Java Compile-time Vs Run-time</h><br>
            <text><b>Compile-time</b></text> is the instance where the code you entered is converted to executable while <text><b>Run-time</b></text> is the instance where the executable is running.<br><br>
            <b>What could happen at <text>Compile time</text></b>?<br>
            <ul>
                <li>Syntax Errors</li>
                <li>Typechecking errors</li>
            </ul>

            <b>What could happen at <text>Run time</text></b>?<br>
            <ul>
                <li>Running out of memory</li>
                <li>Division by zero</li>
                <li>Trying to open a file that isn't there</li>
            </ul>

            <br><img src="../img/run-compile-time.jpg" style="width:40%;height:40%;"><br>

            <!-- ****************************************************************** -->
            <h id="work-sec">How Java works</h><br>
            <ul>
                <li>Source file(.java)</li>
                <li>run source file through <text><b>Java Compiler (javac)</b></text>. It checks for error and syntax in the source file. 
                    It transforms source file into <text><b>bytecode</b></text>. The bytecode is platform independent, 
                    because it's targeted at Java Virtual Machine.</li>
                <li>Compiler creates <text><b>classfile</b></text>. This classfile is coded into bytecode. The classfile is <text><b>portable</b></text> and can be ran on any platform.</li>
                <li><text><b>Java Virtual Machine</b></text> runs the classfile. It is a specification that provides <text><b>run-time environment</b></text> in which java bytecode can be executed.</li>
                <li><text><b>Java Runtime Environment (JRE) </b></text>refers to a runtime environment in which java bytecode can be executed. It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that JVM uses at runtime.</li>
                <li><text><b>Java Development Kit (JDK) </b></text>a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (java), a compiler (javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development.</li>
            </ul>
            <b>In general</b><br>
            <ul>
                <li><mark><b>JDK</b></mark>: provides the environment to Develop and execute(run ) the Java program. (Development tools, and JRE)</li>
                <li><mark><b>JRE</b></mark>: provides environment to only run(not develop) the java program. JRE is only used by them who only wants to run the Java Programs i.e. end users of your system. Contains built in libraries, JVM, toolkits.</li>
                <li><mark><b>JVM</b></mark>: contained in both JRE and JDK. JVM is responsible for executing the java program line by line. Also known as <mark>interpreter</mark></li>
            </ul>

            <!-- ****************************************************************** -->
            <h id="class-loader-sec">Class loader</h><br>
            The Java Class loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.<br>

            <br>

            <!-- ****************************************************************** -->
            <h id="exception-sec">Exceptions</h><br>
            Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.<br>
            <br><img src="../img/exception.jpg" style="width:40%;height:40%;"><br>
            <br>
            <b>Error vs Exception</b><br>
            <text>Error</text>: An Error indicates serious problem that a application should not try to catch. It is impossible to recovery.<br>
            <text>Exception</text>: Exception indicates conditions that a application might try to catch.<br>
            <br>
            <b>How JVM handles exceptions</b><br>
            <ul>
                <li>If an exception has occurred, the method creates an Object known as <text><b>Exception Object</b></text> and hands it off to the JVM. (<text>throwing an Exception</text>)</li>
                <li>The exception object contains <text>name</text> and <text>description</text> of the exception, and <text>current state</text> of the program where exception has occurred.</li>
                <li>There might be the list of the methods that had been called to get to the method where exception was occurred. This ordered list of the methods is called <text><b>Call Stack</b></text>.</li>
                <li>The run-time system searches the call stack to find <text><b>Exception Handler.</b></text>
                    <ul>
                        <li>If found: run-time system pass exception to the handler</li>
                        <li>If not found: run-time system handover the Exception Object to <text>default exception handler</text>.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Types of Exception</b><br>
            <ul>
                <li>Checked Exception
                    <ul>
                        <li>All exceptions other than <text><b>Runtime Exceptions</b></text> are known as Checked exceptions as the 
                            compiler checks them during compilation to see whether the programmer has handled them or not.
                            e.g.IOException, SQLException etc.</li>
                    </ul>
                </li>
                <li>Unchecked Exception
                    <ul>
                        <li>Runtime Exceptions are also known as Unchecked Exceptions. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Throw vs Throws</b>
            <ul>
                <li>Throw
                    <ul>
                        <li>The throw keyword in Java is used to explicitly throw an exception from a method or any block of code. We can throw either checked or unchecked exception.</li>
                    </ul>
                </li>
                <li>Throws
                    <ul>
                        <li>throws keyword is required only for <text><b>checked exception</b></text> and usage of throws keyword for unchecked exception is meaningless.</li>
                    </ul>
                </li>
            </ul>
            
            <br>

            <!-- ****************************************************************** -->
            <h id="lang-sec">java.lang and java.util</h><br>
            <b>Java.lang</b> is a package which contains the classes like 
            System, String, String Buffer etc., This package doesn't 
            have to be explicitly imported as they are imported by 
            default.<br>
            <b>java.util</b> is a package which contains classes like 
            Date, Vector, Dictionary, hashtable etc., This has to be 
            imported everytime you use it in your program<br>

            <br>

            <!-- ****************************************************************** -->
            <h id="mem-model-sec">Memory Model</h><br>
            <b>Stack</b>: Stack memory is responsible for holding references to heap objects and for storing value types. 
            Thread has its own stack. Only exist within the scope of the function, once return, they are destroyed.<br>
            <b>Heap</b>: referenced by stack. Objects are created on heap.<br>
            
            <br>
            
            <!-- ****************************************************************** -->
            <h id="array-copy-sec">Array Copy</h><br>
            <ul>Ways to achieve array copy:
                <li><text>Object.clone()</text>: provided by Object class</li>
                <li><text>System.arraycopy()</text>: provided by System class</li>
                <li><text>Arrays.copyOf()</text></li>
                <li><text>Arrays.copyOfRange()</text>: uses System.arraycopy() method itself</li>
            </ul>

            <!-- ****************************************************************** -->
            <h id="serial-sec">Serialization</h><br>
            <mark>Serialization</mark> is a mechanism of converting the state of an object into a <text>byte stream</text>.<br>
            <mark>Deserialization</mark> is the reverse process where the byte stream is used to recreate the actual Java object in memory.<br>
            <ul>
                <li>If you want a class object to be <text>serializable</text>, all you need to do it implement the <mark>java.io.Serializable</mark> interface.</li>
                <li>Serialization in java is implemented by <mark>ObjectInputStream</mark> and <mark>ObjectOutputStream</mark>.</li>
            </ul>

            <b>Example:</b><br>
            Example of Serialize to a file and Deserialize from the same file.
        
            <pre class="prettyprint">
                import java.io.FileInputStream;
                import java.io.FileOutputStream;
                import java.io.IOException;
                import java.io.ObjectInputStream;
                import java.io.ObjectOutputStream;

                public class SerializationUtil {
                    // deserialize to Object from given file
                    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
                        FileInputStream fis = new FileInputStream(fileName);
                        ObjectInputStream ois = new ObjectInputStream(fis);
                        Object obj = ois.readObject();
                        ois.close();
                        return obj;
                    }

                    // serialize the given object and save it to file
                    public static void serialize(Object obj, String fileName) throws IOException {
                        FileOutputStream fos = new FileOutputStream(fileName);
                        ObjectOutputStream oos = new ObjectOutputStream(fos);
                        oos.writeObject(obj);
                        fos.close();
                    }
                }
            </pre>

            <pre class="prettyprint">
                import java.io.IOException;

                public class SerializationTest {
                    
                    public static void main(String[] args) {
                        String fileName="employee.ser";
                        Employee emp = new Employee();
                        emp.setId(100);
                        emp.setName("Pankaj");
                        emp.setSalary(5000);
                        
                        //serialize to file
                        try {
                            SerializationUtil.serialize(emp, fileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                            return;
                        }
                        
                        Employee empNew = null;
                        try {
                            empNew = (Employee) SerializationUtil.deserialize(fileName);
                        } catch (ClassNotFoundException | IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            </pre>
            <br>

            <ul><b>Serialization Methods</b>
                <li><text>readObject(ObjectInputStream ois)</text>: If this method is present in the class, ObjectInputStream readObject() method will use this method for reading the object from stream.</li>
                <li><text>writeObject(ObjectOutputStream oos)</text>: If this method is present in the class, ObjectOutputStream writeObject() method will use this method for writing the object to stream. </li>
                <li><text>Object writeReplace()</text>: If this method is present, then after serialization process this method is called and the object returned is serialized to the stream.</li>
                <li><text>Object readResolve()</text>: If this method is present, then after deserialization process, this method is called to return the final object to the caller program.</li>
            </ul>

            <ul><b>Serialization with Inheritance</b>
                <li><b><text>Case 1</text>: If superclass is serializable then subclass is automatically serializable</b>
                    <ul>
                        <li>If superclass is Serializable, then by default every subclass is serializable.</li>
                    </ul>
                </li>
                <li><b><text>Case 2</text>: If a superclass is not serializable then subclass can still be serialized</b>
                    <ul>
                        <li>Even though superclass doesn't implements Serializable interface, we can serialize subclass object if subclass itself implements Serializable interface.</li>
                    </ul>
                </li>
                <li><b><text>Case 3</text>: If the superclass is serializable but we don't want the subclass to be serialized</b>
                    <ul>
                        <li>One possible way by which a programmer can achieve this is by implementing the <mark>writeObject()</mark> and <mark>readObject()</mark> methods in the subclass and needs to throw NotSerializableException from these methods.</li>
                    </ul>
                </li>
            </ul>

            <b><text>transient</text> keyword in Java</b><br>
            <ul>
                <li>If we don't want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.</li>
                <li>transient keyword plays an important role to meet security constraints. There are various real-life examples where we don't want to save private data in file. </li>
            </ul>

            <!-- ****************************************************************** -->
            <h id="multi-sec">Java Multithreading</h><br>
            <b>Life Cycle of a Thread</b><br>
            <img src="../img/Thread_Life_Cycle.jpg" style="width:40%;height:40%;"><br>
            <ul>
                <li><text>New</text>: A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread.</li>
                <li><text>Runnable</text>: After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.</li>
                <li><text>Waiting</text>: Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task. A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.</li>
                <li><text>Timed Waiting</text>: A runnable thread can enter the timed waiting state for a specified interval of time.</li>
                <li><text>Terminated</text>: A runnable thread enters the terminated state when it completes its task or otherwise terminates.</li>
            </ul>


            <ul><b>Thread creation by extending the Thread class</b>
                <li>Create a class that extends the java.lang.Thread class</li>
                <li>This class overrides the <text>run()</text> method available in the <text>Thread</text> class.</li>
                <li> A thread begins its life inside <text>run()</text> method. We create an object of our new class and call <text>start()</text> method to start the execution of a thread.</li>
                <li>Start() invokes the run() method on the Thread object.</li>
            </ul>

            <pre class="prettyprint">
                    // Java code for thread creation by extending the Thread class 
                    class MultithreadingDemo extends Thread { 
                        public void run() { 
                            try { 
                                // Displaying the thread that is running 
                                System.out.println ("Thread " + Thread.currentThread().getId() + " is running"); 
                      
                            } 
                            catch (Exception e) { 
                                // Throwing an exception 
                                System.out.println ("Exception is caught"); 
                            } 
                        } 
                    } 
                      
                    // Main Class 
                    public class Multithread { 
                        public static void main(String[] args) { 
                            int n = 8; // Number of threads 
                            for (int i=0; i<8; i++) { 
                                MultithreadingDemo object = new MultithreadingDemo(); 
                                object.start(); 
                            } 
                        } 
                    } 

                    /* Output
                    Thread 8 is running
                    Thread 9 is running
                    Thread 10 is running
                    Thread 11 is running
                    Thread 12 is running
                    Thread 13 is running
                    Thread 14 is running
                    Thread 15 is running */
            </pre>

            <ul><b>Thread creation by implementing the Runnable Interface</b>
                <li>Create a new class which implements <text>java.lang.Runnable</text> interface and <text>override run()</text>> method.</li>
                <li>Then instantiate a <text>Thread object</text> and call <text>start()</text> method on this object.</li>
            </ul>
            <pre class="prettyprint">
                    // Java code for thread creation by implementing the Runnable Interface 
                    class MultithreadingDemo implements Runnable { 
                        public void run() { 
                            try { 
                                // Displaying the thread that is running 
                                System.out.println ("Thread " + Thread.currentThread().getId() + " is running"); 
                      
                            } 
                            catch (Exception e) { 
                                // Throwing an exception 
                                System.out.println ("Exception is caught"); 
                            } 
                        } 
                    } 
                      
                    // Main Class 
                    class Multithread { 
                        public static void main(String[] args) { 
                            int n = 8; // Number of threads 
                            for (int i=0; i<8; i++) { 
                                Thread object = new Thread(new MultithreadingDemo()); 
                                object.start(); 
                            } 
                        } 
                    } 
            </pre>

            <ul><b>Thread Class vs Runnable Interface</b>
                <li>If we extend the <text>Thread class</text>, our class cannot extend any other class because Java doesn't support <text>multiple</text> inheritance. But, if we implement the <text>Runnable interface</text>, our class can still extend other base classes.</li>
                <li>We can achieve basic functionality of a thread by extending <text>Thread class</text> because it provides some inbuilt methods like yield(), interrupt() etc. that are not available in <text>Runnable interface</text>.</li>
            </ul>
            
            <ul><b>join()</b>
                <li>If <mark>t</mark> is a Thread object whose thread is currently executing, then <mark>t.join();</mark> it causes the current thread to pause its execution until <mark>thread t</mark> completes its execution.</li>
                <li>overloaded join()
                    <ul>
                        <li>public final void join()</li>
                        <li>public final synchronized void join(long millis)</li>
                        <li>public final synchronized void join(long millis, int nanos)</li>
                    </ul>
                </li>
                <li>join() example
                    <pre class="prettyprint">
                        public class MultiThreading implements Runnable{
                            public void run() {
                                Thread info = Thread.currentThread();
                                System.out.println(info.getName());
                            }
                            
                            public static void main(String args[]) {
                                
                                Thread t1 = new Thread(new MultiThreading());
                                Thread t2 = new Thread(new MultiThreading());
                                
                                // start t2
                                t2.start();
                                
                                // use join() to let t1 wait until t2 terminated
                                try {
                                    t2.join();
                                } catch(InterruptedException e) {
                                    e.printStackTrace();
                                }
                                
                                // start t1
                                t1.start();
                            }
                        }

                        /* Output:
                            Thread-1
                            Thread-0
                        */
                    </pre>
                </li>
            </ul>

            <ul><b>Synchronized</b>
                <li>Why use: situation where multiple threads try to access the same resources</li>
                <li>Using synchronized blocks: All synchronized blocks synchronized on the same object can only have <mark>one thread</mark> executing inside them at a time.</li>
            </ul>
            <pre class="prettyprint">
                    // Only one thread can execute at a time. 
                    // sync_object is a reference to an object
                    // whose lock associates with the monitor. 
                    // The code is said to be synchronized on
                    // the monitor object
                    synchronized(sync_object) {
                       // Access shared variables and other
                       // shared resources
                    }
            </pre>

            <ul><b>Interthread Communication</b>
                <li>Why use: when threads need to exchange information</li>
                <li>Methods:
                    <ul>
                        <li><text>public void wait()</text>: Causes the <mark>current thread</mark> to wait until another thread invokes the <mark>notify()</mark>.</li>
                        <li><text>public void notify()</text>: Wakes up a single thread that is waiting on this object's monitor.</li>
                        <li><text>public void notifyAll()</text>: Wakes up all the threads that called wait( ) on the same object.</li>
                        <li>All three methods can be called only from within a <text>synchronized</text> context</li>
                    </ul>
                </li>
            </ul>

            <ul><b>Deadlock</b>
                <li>Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.</li>
                <li>Deadlock occurs when multiple threads need the same locks but obtain them in different order.</li>
                <li>Avoid:
                    <ul>
                        <li>Avoid Nested Locks</li>
                        <li>Avoid Unnecessary Locks</li>
                        <li>Using thread join</li>
                    </ul>
                </li>
                <li>Write code to result in <text>deadlock</text>:
                    <pre class="prettyprint">
                        public class Deadlock{

                            public void method1(){
                                synchronized(String.class){
                                    System.out.println("acquired lock on String.class");

                                    synchronized(Integer.class){
                                        System.out.println("acquired lock on Integer.class");
                                    }
                                }
                            }

                            public void method2(){
                                synchronized(Integer.class){
                                    System.out.println("acquired lock on Integer.class");

                                    synchronized(String.class){
                                        System.out.println("acquired lock on String.class");
                                    }
                                }
                            }
                        }
                    </pre>
                    <ul>
                        <li>If <text>method1()</text> and <text>method2()</text> both will be called by two or many threads , there is a good chance of <text>deadlock</text> because if thread 1 acquires lock on 
                            <text>Sting object</text> while executing method1() and thread 2 acquires lock on Integer object while executing method2() both will be waiting for each other 
                            to release lock on Integer and String to proceed further which will never happen.</li>
                        <li>Fix: 
                            <pre class="prettyprint">
                                public class Deadlock{
        
                                    public void method1(){
                                        synchronized(Integer.class){
                                            System.out.println("acquired lock on Integer.class");
        
                                            synchronized(String.class){
                                                System.out.println("acquired lock on String.class");
                                            }
                                        }
                                    }
        
                                    public void method2(){
                                        synchronized(Integer.class){
                                            System.out.println("acquired lock on Integer.class");
        
                                            synchronized(String.class){
                                                System.out.println("acquired lock on String.class");
                                            }
                                        }
                                    }
                                }
                            </pre>
                        </li>
                    </ul>
                </li>
            </ul>

            <b>Difference between synchronized block and method</b><br>
            Main difference between <text>synchronized method</text> and <text>synchronized block</text> is selection of lock on which <text>critical section</text> is locked.<br>
            <ul>
                <li><text>Synchronized method</text> vs <text>Synchronized block</text>: <text>Synchronized block</text> is more preferred way because it doesn't lock the <text>Object</text>, 
                    <text>synchronized methods</text> lock the Object and if there are multiple synchronization blocks in the class, even though they are not related, 
                    it will stop them from execution and put them in wait state to get the lock on Object.</li>
                <li><text>Synchronized block</text> generally reduce scope of lock.</li>
                <li>In case of <text>synchronized method</text>, lock is acquired by thread when it enter <text>method</text> and released when it leaves method, either normally or by throwing Exception.</li>
                <li>In case of <text>synchronized block</text>, thread acquires lock when they enter <text>synchronized block</text> and release when they leave synchronized block.</li>
                <li>
                    <pre class="prettyprint">
                        /**
                        * Java class to demonstrate use of synchronization method and block in Java
                        */
                        public class SycnronizationExample{
                            public synchronized void lockedByThis(){
                                System.out.println(" This synchronized method is locked by current" instance of object i.e. this");
                            }
                        
                            public static synchronized void lockedByClassLock(){
                                System.out.println("This static synchronized method is locked by class level lock of this class i.e. SychronizationExample.class");
                        
                            }
                        
                            public void lockedBySynchronizedBlock(){
                                System.err.println("This line is executed without locking");
                            
                                Object obj = String.class; //class level lock of Stirng class
                            
                                synchronized(obj){
                                    System.out.println("synchronized block, locked by lock represented using obj variable");
                                }
                            }     
                        }
                    </pre>
                </li>
            </ul>

            <b>Volatile</b><br>
            <ul>
                <li>used to signal threads, a compiler that this particular variables value are going to be updated by <text>multiple threads</text> inside Java application.</li>
                <li>The volatile keyword can only be applied to a <text>variable</text>, it can not be applied to class or method. using volatile keyword along with class and method is a compiler error.</li>
                <li>The values of volatile variable will <text>never be cached</text> and all writes and reads will be done to and from the <text>main memory</text>.</li>
                <li>When to use: 
                    <ul>
                        <li>In some cases we may only desire the <text>visibility</text> and <text><mark>not</mark> atomicity</text>. Use of synchronized in such situation is an <text>overkill</text> and may cause scalability problems.</li>
                        <li>Volatile variables have the <text>visibility features</text> of synchronized but <text><mark>not</mark> the atomicity</text> features.</li>
                        <li>Any variable which is shared between multiple threads should be made variable, in order to ensure that all thread must see the latest value of the volatile variable.</li>
                    </ul>
                </li>
            </ul>

            <b>wait(), notify(), notifyAll()</b><br>
            <ul>
                <li><text>wait()</text>: tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls <text>notify()</text>.</li>
                <li><text>notify()</text>: wakes up the first thread that called <text>wait()</text> on the same object.</li>
                <li><text>notifyAll()</text>: wakes up all the threads that called wait() on the same object.</li>
                <li>Producer and Consumer problem:
                    <ul>
                        <li>Producer:
                            <pre class="prettyprint">
                                import java.util.Queue;
                                import java.util.Random;
                                
                                public class Producer implements Runnable{
                                    private Queue<Integer> q;
                                    private int max;
                                    
                                    public Producer(Queue<Integer> q, int max) {
                                        this.q = q;
                                        this.max = max;
                                    }
                                    
                                    @Override
                                    public void run() {
                                        while (true) {	// a infinite loop to create and add random numbers
                                            synchronized(q) { // synchronized block: no other thread should modify the queue when we are doing condition check.
                                                while (q.size() == max) {	// IMPORTANT: it cannot assume that the state it was waiting for is still valid. 
                                                                            // It may have been valid in the past, but the 
                                                                            // state may have been changed after the notify() 
                                                                            // method was called and before the consumer thread woke up. 
                                                    try {
                                                        System.out.println("producer queue is full");
                                                        q.wait();	// wait until Consumer remove an item from queue
                                                
                                                    } catch(Exception e) {
                                                        e.printStackTrace();
                                                    }
                                                }
                                                Random r = new Random();
                                                int i = r.nextInt();
                                                q.add(i);
                                                System.out.println("added new item in Producer: " + i);
                                                q.notifyAll();	// notify all that new item added
                                            }
                                        }
                                    }
                                }
                            </pre>
                        </li>
                        <li>Consumer: 
                            <pre class="prettyprint">
                                import java.util.Queue;

                                public class Consumer implements Runnable{
                                    private Queue<Integer> q;
                                    
                                    public Consumer(Queue<Integer> q, int max) {
                                        this.q = q;
                                    }
                                    
                                    @Override
                                    public void run() {
                                        while (true) {
                                            synchronized(q) {
                                                while (q.isEmpty()) {
                                                    System.out.println("queue is empty");
                                                    try {
                                                        q.wait();
                                                    } catch(Exception e) {
                                                        e.printStackTrace();
                                                    }
                                                }
                                                System.out.println("Consumed: " + q.remove());
                                                q.notifyAll();
                                            }
                                        }
                                    }
                                }
                            </pre>
                        </li>
                        <li>main:
                            <pre class="prettyprint">
                                import java.util.LinkedList;
                                import java.util.Queue;
                                
                                public class MultiThreading {
                                    public static void main(String args[]) {
                                        // IMPORTANT: should create one queue for both thread (shared object), otherwise it's not shared
                                        Queue<Integer> queue = new LinkedList<Integer>();
                                        Thread pThread = new Thread(new Producer(queue, 10));
                                        Thread cThread = new Thread(new Consumer(queue, 10));
                                        
                                        pThread.start();
                                        cThread.start();
                                    }
                                }
                            </pre>
                        </li>
                    </ul>
                </li>
            </ul>


            <b>Java Multithreading Questions:</b>
            <ul>
                <li>Difference between <b>start()</b> and <b>run()</b>: 
                    <ul>
                        <li><text>start method</text> creates a <text>new thread</text> and call the code written inside the run method on a new thread while <text>calling run method</text> executes that code on the <text>same thread</text>.</li>
                    </ul>
                </li>
                <li>Difference between <b>wait()</b> and <b>sleep()</b>
                    <ul>
                        <li><text>wait</text> will release the lock and must be called from the <text>synchronized context</text>, while <text>sleep</text> will only pause the thread for some time and <text>keep the lock</text>.</li>
                        <li><text>wait()</text> method should be used in conjunction with <text>notify()</text> or <text>notifyAll()</text> method and intended for communication between two threads in Java.</li>
                        <li><text>Thread.sleep()</text> method is a utility method to introduce <text>short pauses</text> during program or thread execution. </li>
                    </ul>
                </li>
                <li><b>How do you detect <text>deadlock</text>?</b>
                    <ul>
                        <li>
                    </ul>
                </li>
            </ul>
       </div>
       
    </body>
</html>
