<!-- This is the About Me page -->
<!DOCTYPE html>
<html>
    <head>
        <title>Pu Chen | Blog</title>

        <!-- CSS links -->
        <link rel="stylesheet" href="../css/archives.css" />
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    </head>

    <body>
        <!-- Navigation Bar -->
        <nav>
            <div class="tag">Core Java | Pu Chen</div>
            <ul>
                <li><a href="../contact.html">Contact</a></li>
                <li><a href="../archives.html">Archives</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
                <li><a href="https://github.com/PuChen7">Projects</a></li>
                <li><a class="active" href="../index.html">Home</a></li>
            </ul>
       </nav>

       <div id="guide"><h><b>Java Fundamental Knowledge</b></h></div>
       <!-- Main body of the front page -->
       <div class="blog-content">
            <h>Java Key Words</h>
            <ul>
                <li><text><b>final</b></text>:
                    <ul>
                        <li><text>Final Class</text> cannot be subclassed</li>
                        <li><text>Final methods</text> cannot be overridden</li>
                        <li><text>Final variables</text> can occur at most once as a left-hand expression on an executed command</li>
                        <li>All methods in a final class are implicitly <text>final</text></li>
                    </ul>
                </li>

                <li><text><b>finally</b></text>
                    <ul>
                        <li><text>Finally block</text> in java can be used to put "cleanup" code such as closing a file, closing connection etc.</li>
                        <li>Java <text>finally block</text> is always executed whether exception is handled or not.</li>
                        <li>This is used to close non-memory resources like file handles, sockets, database connections</li>
                    </ul>
                </li>

                <li><text><b>static</b></text>
                    <ul>
                        <li><text>static</text> members belong to the class instead of a specific instance.</li>
                    </ul>
                </li>
            </ul>

            <h>Access Modifiers</h>
            <ul>
                <li> <text><b>default</b></text>: Visible to the package. No modifiers are needed.
                    <ul>
                        <li>A variable or method declared without any access control modifier is available to any other class in the same package.</li>
                    </ul>
                </li>
                <li><text><b>private</b></text>: Visible to the class only
                    <ul>
                        <li>Methods, variables, and constructors that are declared <text>private</text> can only be accessed within the declared class itself.</li>
                        <li><text>Private access modifier</text> is the most restrictive access level. Class and interfaces cannot be private.</li>
                    </ul>
                </li>
                <li><text><b>public</b></text>: Visible to the world
                    <ul>
                        <li>A class, method, constructor, interface, etc. declared <text>public</text> can be accessed from any other class.</li>
                    </ul>
                </li>
                <li><text><b>protected</b></text>: Visible to the package and all subclasses
                    <ul>
                        <li>Variables, methods, and constructors, which are declared <text>protected</text> in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.</li>
                        <li>The protected access modifier cannot be applied to class and interfaces. </li>
                    </ul>
                </li>
            </ul>

            <img src="../img/access-modifiers.jpg" style="width:60%;height:60%;"><br>

            <br>

            <h>Wrapper Class</h><br>
            Wrapper classes are used to convert any data type into an object.
            <ul>
                <li><text><b>Autoboxing</b></text>: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing.</li>
                <li><text><b>Unboxing</b></text>: Automatically converting an object of a wrapper class to its corresponding primitive type is known as unboxing. </li>
            </ul>

            <br>

            <h>Generics</h><br>
            Generics was added in Java 5 to provide compile-time type checking 
            and removing risk of ClassCastException that was common while working with collection classes.<br>
            It provides compile time type-safety and ensures that you only insert correct Type in collection and avoids ClassCastException in runtime.<br>
            <b>Example:</b><br>
            <pre class="prettyprint">
                List<String> list = new ArrayList<String>();
                list.add("1");
                list.add("string");
                String str = list.get(1);
                System.out.println(str);    // output: string
            </pre>
            <b>Generics for loop:</b><br>
            <pre class="prettyprint">
                List<String> strings = new ArrayList<String>();
                //... add String instances to the strings list...      
                for(String aString : strings){
                    System.out.println(aString);
                }
            </pre>

            <br>

            <h>Comparable and Comparator</h><br>
            <text><b>Comparable</b></text> and <text><b>Comparator</b></text> both are interfaces and can be used to sort collection elements.
            It provide <text><b>single sorting sequence</b></text> only.<br><br>
            
            <b>Comparable Interface</b><br>
            Method: <text><b>compareTo(Object)</b></text>: used to compare the current object with the specified object.<br>
            It compares strings on the basis of <text><b>Unicode value</b></text> of each character in the strings.<br>
            return: >: positive int / ==: 0 / <: negative int<br>
            <br>
            Can used to sort:
            <ul>
                <li>String objects</li>
                <li>Wrapper class objects</li>
                <li>User-defined class objects</li>
            </ul>

            <b>Comparator Interface</b><br>
            Used to order the objects of user-defined class. It provides <text><b>multiple</b></text> sorting sequence <br>
            Method: <text><b>compare(Object obj1,Object obj2)</b></text> and <text><b>equals(Object element)</b></text>.

            <br>

            <b>When to use Comparable and Comparator</b><br>
            <mark>Comparable</mark>: when sorting based on natural order.<br>
            <mark>Comparator</mark>: when sorting based on special ordering.<br>

            <br>

            <h>Garbage Collector</h><br>
            <ul>
                <li>Not to care for all those objects which are no longer in use. <text>Garbage collector</text> destroys these objects.</li>
                <li>Garbage collector is best example of <text>Daemon thread</text> as it is always running in background.</li>
                <li>Main objective of Garbage Collector is to free <text>heap memory</text> by destroying unreachable objects.</li>
                <li>Eligibility for garbage collection:
                    <ul>
                        <li><text>Unreachable objects</text> : An object is said to be unreachable iff it doesnâ€™t contain any reference to it.</li>
                        <li>Object created inside method</li>
                        <li>Nullifying the reference variable</li>
                    </ul>
                </li>
            </ul>

            <h>Thread</h><br>
            <br>

            <h>Java Compile-time Vs Run-time</h><br>
            <text><b>Compile-time</b></text> is the instance where the code you entered is converted to executable while <text><b>Run-time</b></text> is the instance where the executable is running.<br><br>
            <b>What could happen at <text>Compile time</text></b>?<br>
            <ul>
                <li>Syntax Errors</li>
                <li>Typechecking errors</li>
            </ul>

            <b>What could happen at <text>Run time</text></b>?<br>
            <ul>
                <li>Running out of memory</li>
                <li>Division by zero</li>
                <li>Trying to open a file that isn't there</li>
            </ul>

            <br><img src="../img/run-compile-time.jpg" style="width:40%;height:40%;"><br>

            <h>How Java works</h><br>
            <ul>
                <li>Source file(.java)</li>
                <li>run source file through <text><b>Java Compiler (javac)</b></text>. It checks for error and syntax in the source file. 
                    It transforms source file into <text><b>bytecode</b></text>. The bytecode is platform independent, 
                    because it's targeted at Java Virtual Machine.</li>
                <li>Compiler creates <text><b>classfile</b></text>. This classfile is coded into bytecode. The classfile is <text><b>portable</b></text> and can be ran on any platform.</li>
                <li><text><b>Java Virtual Machine</b></text> runs the classfile. It is a specification that provides <text><b>run-time environment</b></text> in which java bytecode can be executed.</li>
                <li><text><b>Java Runtime Environment (JRE) </b></text>refers to a runtime environment in which java bytecode can be executed. It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that JVM uses at runtime.</li>
                <li><text><b>Java Development Kit (JDK) </b></text>a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (java), a compiler (javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development.</li>
            </ul>
            <b>In general</b><br>
            <ul>
                <li><mark><b>JDK</b></mark>: provides the environment to Develop and execute(run ) the Java program. (Development tools, and JRE)</li>
                <li><mark><b>JRE</b></mark>: provides environment to only run(not develop) the java program. JRE is only used by them who only wants to run the Java Programs i.e. end users of your system. Contains built in libraries, JVM, toolkits.</li>
                <li><mark><b>JVM</b></mark>: contained in both JRE and JDK. JVM is responsible for executing the java program line by line. Also known as <mark>interpreter</mark></li>
            </ul>

            <h>What is class loader</h><br>
            The Java Class loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.<br>

            <h>Lambda Expression</h><br>

            <br>

            <h>Exceptions</h><br>
            Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.<br>
            <br><img src="../img/exception.jpg" style="width:40%;height:40%;"><br>
            <br>
            <b>Error vs Exception</b><br>
            <text>Error</text>: An Error indicates serious problem that a application should not try to catch. It is impossible to recovery.<br>
            <text>Exception</text>: Exception indicates conditions that a application might try to catch.<br>
            <br>
            <b>How JVM handles exceptions</b><br>
            <ul>
                <li>If an exception has occurred, the method creates an Object known as <text><b>Exception Object</b></text> and hands it off to the JVM. (<text>throwing an Exception</text>)</li>
                <li>The exception object contains <text>name</text> and <text>description</text> of the exception, and <text>current state</text> of the program where exception has occurred.</li>
                <li>There might be the list of the methods that had been called to get to the method where exception was occurred. This ordered list of the methods is called <text><b>Call Stack</b></text>.</li>
                <li>The run-time system searches the call stack to find <text><b>Exception Handler.</b></text>
                    <ul>
                        <li>If found: run-time system pass exception to the handler</li>
                        <li>If not found: run-time system handover the Exception Object to <text>default exception handler</text>.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Types of Exception</b><br>
            <ul>
                <li>Checked Exception
                    <ul>
                        <li>All exceptions other than <text><b>Runtime Exceptions</b></text> are known as Checked exceptions as the 
                            compiler checks them during compilation to see whether the programmer has handled them or not.
                            e.g.IOException, SQLException etc.</li>
                    </ul>
                </li>
                <li>Unchecked Exception
                    <ul>
                        <li>Runtime Exceptions are also known as Unchecked Exceptions. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <b>Throw vs Throws</b>
            <ul>
                <li>Throw
                    <ul>
                        <li>The throw keyword in Java is used to explicitly throw an exception from a method or any block of code. We can throw either checked or unchecked exception.</li>
                    </ul>
                </li>
                <li>Throws
                    <ul>
                        <li>throws keyword is required only for <text><b>checked exception</b></text> and usage of throws keyword for unchecked exception is meaningless.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <h><code>java.lang</code> and <code>java.util</code></h><br>
            <code><b>Java.lang</b></code> is a package which contains the classes like 
            System, String, String Buffer etc., This package doesn't 
            have to be explicitly imported as they are imported by 
            default.<br>
            <code><b>java.util</b></code> is a package which contains classes like 
            Date, Vector, Dictionary, hashtable etc., This has to be 
            imported everytime you use it in your program<br>

            <br>

            <h>Memory Model</h><br>
            <b>Stack</b>: Stack memory is responsible for holding references to heap objects and for storing value types. 
            Thread has its own stack. Only exist within the scope of the function, once return, they are destroyed.<br>
            <b>Heap</b>: referenced by stack. Objects are created on heap.<br>
            
            <br>
            
            <h>Array Copy</h><br>
            <ul>Ways to achieve array copy:
                <li><text>Object.clone()</text>: provided by Object class</li>
                <li><text>System.arraycopy()</text>: provided by System class</li>
                <li><text>Arrays.copyOf()</text></li>
                <li><text>Arrays.copyOfRange()</text>: uses System.arraycopy() method itself</li>
            </ul>

            <h>Serialization</h><br>
            <mark>Serialization</mark> is a mechanism of converting the state of an object into a <text>byte stream</text>.<br>
            <mark>Deserialization</mark> is the reverse process where the byte stream is used to recreate the actual Java object in memory.<br>
            <ul>
                <li>If you want a class object to be <text>serializable</text>, all you need to do it implement the <mark>java.io.Serializable</mark> interface.</li>
                <li>Serialization in java is implemented by <mark>ObjectInputStream</mark> and <mark>ObjectOutputStream</mark>.</li>
            </ul>

            <b>Example:</b><br>
            Example of Serialize to a file and Deserialize from the same file.
        
            <pre class="prettyprint">
                import java.io.FileInputStream;
                import java.io.FileOutputStream;
                import java.io.IOException;
                import java.io.ObjectInputStream;
                import java.io.ObjectOutputStream;

                public class SerializationUtil {
                    // deserialize to Object from given file
                    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
                        FileInputStream fis = new FileInputStream(fileName);
                        ObjectInputStream ois = new ObjectInputStream(fis);
                        Object obj = ois.readObject();
                        ois.close();
                        return obj;
                    }

                    // serialize the given object and save it to file
                    public static void serialize(Object obj, String fileName) throws IOException {
                        FileOutputStream fos = new FileOutputStream(fileName);
                        ObjectOutputStream oos = new ObjectOutputStream(fos);
                        oos.writeObject(obj);
                        fos.close();
                    }
                }
            </pre>

            <pre class="prettyprint">
                import java.io.IOException;

                public class SerializationTest {
                    
                    public static void main(String[] args) {
                        String fileName="employee.ser";
                        Employee emp = new Employee();
                        emp.setId(100);
                        emp.setName("Pankaj");
                        emp.setSalary(5000);
                        
                        //serialize to file
                        try {
                            SerializationUtil.serialize(emp, fileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                            return;
                        }
                        
                        Employee empNew = null;
                        try {
                            empNew = (Employee) SerializationUtil.deserialize(fileName);
                        } catch (ClassNotFoundException | IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            </pre>
            <br>

            <ul><b>Serialization Methods</b>
                <li><text>readObject(ObjectInputStream ois)</text>: If this method is present in the class, ObjectInputStream readObject() method will use this method for reading the object from stream.</li>
                <li><text>writeObject(ObjectOutputStream oos)</text>: If this method is present in the class, ObjectOutputStream writeObject() method will use this method for writing the object to stream. </li>
                <li><text>Object writeReplace()</text>: If this method is present, then after serialization process this method is called and the object returned is serialized to the stream.</li>
                <li><text>Object readResolve()</text>: If this method is present, then after deserialization process, this method is called to return the final object to the caller program.</li>
            </ul>

            <ul><b>Serialization with Inheritance</b>
                <li><b><text>Case 1</text>: If superclass is serializable then subclass is automatically serializable</b>
                    <ul>
                        <li>If superclass is Serializable, then by default every subclass is serializable.</li>
                    </ul>
                </li>
                <li><b><text>Case 2</text>: If a superclass is not serializable then subclass can still be serialized</b>
                    <ul>
                        <li>Even though superclass doesn't implements Serializable interface, we can serialize subclass object if subclass itself implements Serializable interface.</li>
                    </ul>
                </li>
                <li><b><text>Case 3</text>: If the superclass is serializable but we don't want the subclass to be serialized</b>
                    <ul>
                        <li>One possible way by which a programmer can achieve this is by implementing the <mark>writeObject()</mark> and <mark>readObject()</mark> methods in the subclass and needs to throw NotSerializableException from these methods.</li>
                    </ul>
                </li>
            </ul>

            <b><text>transient</text> keyword in Java</b><br>
            <ul>
                <li>If we donâ€™t want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.</li>
                <li>transient keyword plays an important role to meet security constraints. There are various real-life examples where we donâ€™t want to save private data in file. </li>
            </ul>
       </div>

    </body>
</html>
