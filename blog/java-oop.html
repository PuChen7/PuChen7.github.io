<!-- This is the About Me page -->
<!DOCTYPE html>
<html>
    <head>
        <title>Pu Chen | Blog</title>

        <!-- CSS links -->
        <link rel="stylesheet" href="../css/blog.css" />
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script>
            $(document).ready(function(){
                
                // Add smooth scrolling to all links
                $("a").on('click', function(event) {
                    // Make sure this.hash has a value before overriding default behavior
                    if (this.hash !== "") {
                        // Prevent default anchor click behavior
                        event.preventDefault();
                
                        // Store hash
                        var hash = this.hash;
                
                        // Using jQuery's animate() method to add smooth page scroll
                        // The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
                        $('html, body').animate({
                        scrollTop: $(this.hash).offset().top - ($('#nav-bar').height()+10)
                        }, 800, function(){
                    
                        // Add hash (#) to URL when done scrolling (default click behavior)
                        window.location.hash = hash;
                        
                        });
                    } // End if
                });
            });                    
        </script>
    </head>

    <body>
        <!-- Navigation Bar -->
        <nav id="nav-bar">
            <div class="tag">Java OOP Concepts | Pu Chen</div>
            <ul>
                <li><a href="../contact.html">Contact</a></li>
                <li><a href="../archives.html">Archives</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
                <li><a href="https://github.com/PuChen7">Projects</a></li>
                <li><a class="active" href="../index.html">Home</a></li>
            </ul>
       </nav>

       <div id="guide"><h><b>Topics Covered in this Page</b></h>
           <ol>
                <li><a href="#object">What is Object, Instance, Class?</a></li>
                <li><a href="constructor">Constructors</a></li>
                <li><a>static keyword</a></li>
                <li><a>this keyword</a></li>
                <li><a>final keyword</a></li>
                <li><a>Inheritance</a></li>
                <li><a>Method Overloading/Overriding</a></li>
                <li><a>Polymorphism</a></li>
                <li><a>Static Binding and Dynamic Binding</a></li>
                <li><a>Abstract Class</a></li>
                <li><a>Interface</a></li>
                <li><a href="#singleton">Singleton</a></li>
            </ol>
       </div>

       <!-- Main body of the front page -->
       <div class="blog-content">
           <h id="object">What is Object, Instance, Class?</h>
            <ul>
                <li>Objects share two characteristics: They all have <text>state</text> and <text>behavior</text>.</li>
                <li>Instance is an instantiation of a class. </li>
                <li>Class is a blueprint that defines object's state and behavior.</li>
                <li>A class encapsulates the static attributes (data) and dynamic behaviors (operations that operate on the data) in a box.</li>
                <li>Class >> Object >> Instance (object is instance of class)</li>
                </p>
            </ul>

            <b>Creating Instances of a Class</b>
                <ul>
                    <li>Declare an instance identifier (instance name) of a particular class.</li>
                    <li>Construct the instance (i.e., allocate storage for the instance and initialize the instance) using the "new" operator.</li>
                </ul>


            <h id="constructor">Constructors</h>
                <p>
                    A constructor is used to construct and initialize all the member variables.
                    The name of the constructor method is the same as the class name.<br>
                    Constructor has no return type. It implicitly returns void.<br> 
                    Constructor can only be invoked via the "new" operator.<br> 
                    Constructors are not inherited.<br>
                    Java compiler creates a default constructor(no-arg constructor) if your class doesn't have any. 
                    Default constructor is used to provide the default values to the object like 0, null etc. depending on the type.<br>
                    <br>
                    Constructor overloading: Constructor overloading in Java is a technique of having more than one constructor with different parameter lists. 
                    They are arranged in a way that each constructor performs a different task. 
                    They are differentiated by the compiler by the number of parameters in the list and their types.
                    <br>Example:<br>
                    <pre class="prettyprint">
                        class Student5{  
                            int id;  
                            String name;  
                            int age;  
                            Student5(int i,String n){  
                                id = i;  
                                name = n;  
                            }  
                            Student5(int i,String n,int a){  
                                id = i;  
                                name = n;  
                                age=a;  
                            }  
                            void display(){System.out.println(id+" "+name+" "+age);}  
                            
                            public static void main(String args[]){  
                                Student5 s1 = new Student5(111,"Karan");  
                                Student5 s2 = new Student5(222,"Aryan",25);
                            }  
                        }
                    </pre>
                </p>
            <br>

            <h>static keyword</h>
            <br><br>
            <b>static variable</b>
                <p>
                    It makes the program memory efficient. static property is shared to all objects. 
                </p>
            <br>

            <b>static method</b>
                <p>
                    A static method belongs to the class rather than object of a class.<br>
                    A static method can be invoked without the need for creating an instance of a class.<br>
                    static method can access static data member and can change the value of it.<br>
                    <br>
                    <u>Restrictions:</u><br>
                    The static method can not use non static data member or call non-static method directly.<br>
                    this and super cannot be used in static context.<br>
                    <br>
                    <u>When to use static method?</u><br>
                    If you are writing utility classes and they are not supposed to be changed.<br>
                    If the method is not using any instance variable.<br>
                    If any operation is not dependent on instance creation.<br>
                    <br>
                    <b>overload static method?</b><br>
                    Yes.<br>
                    <pre class="prettyprint">
                        public class Test {
                            public static void foo() {
                                System.out.println("Test.foo() called ");
                            }
                            public static void foo(int a) { 
                                System.out.println("Test.foo(int) called ");
                            }
                            public static void main(String args[])
                            { 
                                Test.foo();
                                Test.foo(10);
                            }
                        }
                        /********************/
                        Output:
                        Test.foo() called 
                        Test.foo(int) called 
                    </pre>
                    <b>overload methods that differ only by static keyword?</b><br>
                    No.<br>
                    <pre class="prettyprint">
                        public class Test {
                            public static void foo() {
                                System.out.println("Test.foo() called ");
                            }
                            public void foo() { // Compiler Error: cannot redefine foo()
                                System.out.println("Test.foo(int) called ");
                            }
                            public static void main(String args[]) { 
                                Test.foo();
                            }
                        }
                        /********************/
                        Output: Compiler Error, cannot redefine foo()
                    </pre>
                </p>
            <br>

            <h><text>this</text> keyword</h>
                <p>
                    <ul>
                        <li>this can be used to refer current class instance variable.</li>
                        <li>this can be used to invoke current class method (implicitly)</li>
                        <li>this() can be used to invoke current class constructor.</li>
                        <li>this can be passed as an argument in the method call.</li>
                        <li>this can be passed as argument in the constructor call.</li>
                        <li>this can be used to return the current class instance from the method.</li>
                    </ul>
                </p>
            
            <h>Inheritance</h>
                <p>
                    <b>Definition</b>: one object acquires all the properties and behaviors of parent object. 
                    It is a <text>IS-A</text> relationship, also known as <text>parent-child</text> relationship.
                    The subclass can add its own fields and methods in addition to the superclass fields and methods.<br>
                    <br>
                    <b>Why use Inheritance?</b><br>
                    <text>1. Code reusability</text><br>
                    create new classes that are built upon existing classes.<br>
                    reuse methods and fields of parent class, and add more functions.<br>
                    <text>2. For Method Overriding</text><br><br>

                    <b>Types of Inheritance:</b><br>
                    1. single<br>
                    2. multilevel<br>
                    3. hierarchical<br>
                    
                    <br>

                    <b>Important facts about inheritance</b>
                    <ul>
                        <li><text>Default superclass</text>: Except Object class, which has no superclass, every class has one and only one direct superclass (single inheritance). In the absence of any other explicit superclass, every class is implicitly a subclass of Object class.</li>
                        <li><text>Superclass can only be one</text>: A superclass can have any number of subclasses. But a subclass can have only one superclass. This is because Java does not support multiple inheritance with classes. Although with interfaces, multiple inheritance is supported by java.</li>
                        <li><text>Inheriting Constructors</text>: A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.</li>
                        <li><text>Private member inheritance</text>: A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods(like getters and setters) for accessing its private fields, these can also be used by the subclass.</li>
                    </ul>
                </p>
            <br>

            <h>Encapsulation</h><br>
                <p>
                    <b>Definition</b>: Wrapping data and methods together.<br>
                    To achieve encapsulation, you can create private variables to hide the data, and provide getter method for other classes to get the private variables.<br>
                    <b><text>Advantages: </text></b>
                    <ul>
                        <li>Provide easy maintenance. </li>
                        <li>You can control the way that accessing the variables, so that you can prevent the data being randomly accessed by other classes.</li>
                        <li>Increase reusability</li>
                    </ul>
                    <b><text>Encapsulation vs Abstraction</text></b>
                    <ul>
                        <li>Encapsulation is data hiding while Abstraction is detail hiding.</li>
                        <li>While encapsulation groups data and methods together, data abstraction deals with exposing the interface to the user and hiding the details of implementation.</li>
                    </ul>
                </p>
            <br>

            <h>Method Overloading</h><br>
                <p>
                    <b>Definition:</b> same name with different parameters.<br>
                    <b>why use?</b> Increases the readability of the program.<br>
                    <b>Overload main method?</b> Yes. But JVM calls main() method which receives string array as arguments only. 

                </p>

            <br>

            <h>Method Overriding</h><br>
                <p> 
                    <b>Definition:</b>If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java.<br>
                    <b>why use?</b>
                        <br>1. used for provide specific implementation of a method that is already provided by its super class.
                        <br>2. used for runtime polymorphism.<br>
                    <br>
                    <b>Rules for Java Method Overriding</b><br>
                        1. method must have same name as in the parent class.<br>
                        2. method must have same parameter as in the parent class.<br>
                        3. must be IS-A relationship (inheritance).<br>

                    <b>Facts:</b><br>
                    1. <text>Override static method?</text> No <br>
                    2. <text>Override main method?</text> No, main() is static <br>

                    <br>

                    <b>Overriding the static method</b><br>
                    If you try to override a static method,  it is known as <text><b>hiding or shadowing</b></text>.<br>

                    <pre class="prettyprint">
                        public class PolymorphismTest {
                            public static void main(String[] args) {
                                Base b = new DerivedOne();
                                b.f(); // prints "Base"
                            
                                b = new Base();
                                b.f();  //prints "Base"
                            }
                        }

                        /*
                            Why prints "Base" in both cases? Because, it only looks at what type variable "b" is? 
                            In both cases of type Base. It does not care what type of object is stored. 
                            Same for variables, and is known as "Shadowing"
                        */
                    </pre>

                    
                </p>

            <br>

            <h><text>final</text> keyword</h>
                <p>
                    <b>final variable</b>: final variable cannot be changed.<br>
                    <b>final method</b>: cannot override it. But final method is inherited.<br>
                    <b>final class</b>: cannot extend it.
                </p>
            <br>

            <h>Polymorphism</h>
                <p>
                    <b>Definition:</b>perform a single action by different ways. 
                    There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism.<br><br>
                    <b>Example:</b>Animal class has sound() method. Cat and Horse extends Animal. Cat implements "Meow", and Horse implements "Neigh".<br>
                    This is one method used in multiple ways. <text>One interface with multiple implementations.</text>
                    <br><br>
                    <b>Compile time/static polymorphism</b><br>
                    Polymorphism that is resolved during <text>compiler time</text> is known as static polymorphism.<br>
                    <text>Method overloading</text> is compile time polymorphism because which method to be called is determined at the run time based on the parameters.<br><br>
                    
                    <b>Run time/dynamic polymorphism</b><br>
                    Method overriding: overridden method is resolved at <text>run time</text>.<br>

                    <b>Composition over inheritance</b><br>
                    <text><b>Composition:</b></text> Has-A relationship. Containing instances of other classes that implement the desired functionality.<br>
                    classes should achieve polymorphic behavior and code reuse by their composition rather than inheritance from a base or parent class.<br>
                </p>
            <br>

            <h>Static Binding and Dynamic Binding</h>
                <p>
                    <b>What is binding?</b><br>Connecting a method call to the method body is known as binding.<br><br>
                    <b>Two types:</b><br>
                    - static binding (early binding)<br>
                    - dynamic binding (late binding)<br>
                    <br>
                    <b>static binding</b><br>
                    When type of the object is determined at <text>compiled time</text>(by the compiler), it is known as static binding.<br>
                    If there is any <text>private</text>, <text>final</text> or <text>static</text> method in a class, there is static binding.<br>
                    <br>
                    <b>why <text>private</text>, <text>final</text> or <text>static</text> method is static binding?</b><br>
                    Compiler knows that all such methods cannot be overridden and will always be accessed by object of local class. 
                    Hence compiler doesn't have any difficulty to determine object of class (local class for sure).<br>
                    <br>
                    <b>dynamic binding</b><br>
                    Dynamic binding is a binding which happens during run time.<br>
                    Method overriding is dynamic binding since the type of the object is determined at the run time.<br>
                </p>
            <br>

            <h>Abstract Class</h>
                <p> 
                    <ul>
                        <li><b>Abstraction</b>: a process of hiding the implementation details and showing only functionality to the user.</li>
                        <li>Two ways to achieve abstraction: <text>abstract class</text>, and <text>interface</text>.</li>
                        <li>An abstract class can not be instantiated, which means you are not allowed to create an object of it.</li>
                        <li>Abstract class doesn't provide 100% abstraction because it allows concrete methods. However, Interface provides 100% abstraction.</li>
                    </ul>
                    <b>Rules:</b>
                    <ul>
                        <li>A class derived from the abstract class must implement <text>ALL</text> those methods that are declared as abstract in the parent class.</li>
                        <li>If a child does not implement all the abstract methods of abstract parent class, then the child class must need to be declared abstract as well.</li>
                        <li>How to use abstract class: extend it and build. Can't create object since there are no implementation.</li>
                    </ul>
                </p>
            <h>Interface</h>
                <p>
                    <b>Why use interface?</b><br>
                    1. To achieve full abstraction.<br>
                    2. multiple inheritance.<br>
                    <br>
                    <b>Rules:</b>
                    <ul>
                        <li>Interface can only have <text>abstract</text> methods. Don't have to put "interface" on the header.</li>
                        <li>Can extends multiple interfaces.</li>
                        <li>If interface1 extends interface2, class implements interface1, then class must implements all methods in both interface1 and interface2.</li>
                        <li>Cannot create object of interfaces.</li>
                        <li>Variables declared in interface are <text>public, static, final</text> by default.</li>
                    </ul>
                </p>
            <br>
            <h>When to use Abstract Class vs Interface</h><br>
            Abstract classes should primarily be used for objects that are closely related (some classes might need to share lines of code, 
            so you can put these code to abstract class). Need to provide default implementation.<br>
            Interfaces are better at providing common functionality for unrelated classes. If need multiple inheritance.<br>

            <br>
            <h>Association > Aggregation > Composition</h><br>
            <b>Association</b>: relation between classes objects. Can be one-to-one, one-to-many, many-to-one, many-to-many. 
            Composition and Aggregation are two forms of Association.<br>
            <b>Aggregation</b>: Has-A relationship. Unidirectional. Entities are <mark>independent</mark>.<br>
            <b>Composition</b>: restricted form of Aggregation. part-of relationship. Entities are <mark>dependent</mark>.<br>

            <h id="singleton">Singleton</h>
            <ul>
                <li>A singleton class is a class that can have only one object (an instance of the class) at a time.</li>
                <li>Purpose of using <text>Singleton</text>: 
                    <ul>
                        <li>control <text>object creation</text>, limiting the number of objects to <text>only one</text>.</li>
                        <li>Singletons often control <text>access to resources</text>, such as database connections or sockets.
                            <ul>
                                <li>For example, if you have a license for only one connection for your database or your JDBC driver 
                                    has trouble with multithreading, the Singleton makes sure that only one connection is made or that 
                                    only one thread can access the connection at a time.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Implementation:
                    <ul>
                        <li>Make constructor as private.</li>
                        <li>Write a static method that has return type object of this singleton class.</li>
                        <li><b>Lazy Initialization</b> - used for single thread
                            <ul>
                                <li>Sample Singleton class:
                                    <pre class="prettyprint">
                                        public class Singleton {
                                            private static Singleton singleton_instance = null;
                                            
                                            /* A private Constructor prevents any other
                                                * class from instantiating.
                                                */
                                            private Singleton() { }
                                            
                                            /* Static 'instance' method */
                                            public static Singleton getInstance( ) {
                                                if(singleton_instance == null) {
                                                    singleton_instance = new Singleton();
                                                }
                                                return singleton_instance;
                                            }
                                            
                                            /* Other methods protected by singleton-ness */
                                            protected static void demoMethod( ) {
                                                System.out.println("demoMethod for singleton");
                                            }
                                        }
                                    </pre>
                                </li>
                                <li>Creating a Singleton class object:
                                    <pre class="prettyprint">
                                        public class SingletonDemo {
                                            public static void main(String[] args) {
                                                Singleton tmp = Singleton.getInstance( );
                                                tmp.demoMethod( );
                                            }
                                        }
                                    </pre>
                                </li>
                            </ul>
                        </li>
                        <li><b>Double Checked Locking</b>
                            <pre class="prettyprint">
                                public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
                                    if(instance == null){
                                        synchronized (ThreadSafeSingleton.class) {
                                            if(instance == null){
                                                instance = new ThreadSafeSingleton();
                                            }
                                        }
                                    }
                                    return instance;
                                }
                            </pre>
                        </li>
                    </ul>
                </li>
            </ul>
            
       </div>

    </body>
</html>
