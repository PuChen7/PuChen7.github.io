<!-- This is the About Me page -->
<!DOCTYPE html>
<html>
    <head>
        <title>Pu Chen | Blog</title>

        <!-- CSS links -->
        <link rel="stylesheet" href="../css/blog.css" />
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    </head>

    <body>
        <!-- Navigation Bar -->
        <nav>
            <div class="tag">Java Collections Framework | Pu Chen</div>
            <ul>
                <li><a href="../contact.html">Contact</a></li>
                <li><a href="../archives.html">Archives</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
                <li><a href="https://github.com/PuChen7">Projects</a></li>
                <li><a class="active" href="../index.html">Home</a></li>
            </ul>
       </nav>

       <div id="guide"><h><b>Java Collections Framework</b></h></div>

       <!-- Main body of the front page -->
       <div class="blog-content">
            Java Collections Framework provides an architecture to store and manipulate the group of objects.<br>
            All collections frameworks contain <text>interfaces, classes, algorithms.</text><br>
            <br>
            <img src="../img/collection-hierarchy.jpg" style="width:40%;height:40%;"><br>
            <br>

            <h>List, Set, Map</h><br>
            <ul>
                <li><b><text>List</text></b>: 
                    <ul>
                        <li><text>Duplicate</text>: allow any number of duplicates</li>
                        <li><text>Order</text>: keeps insertion order</li>
                        <li><text>null elements</text>: allow any number of null values</li>
                        <li><text>Implementations</text>: ArrayList, LinkedList, Vector</li>
                        <li>When to use:
                            <ul>
                                <li>need to access elements frequently by using the index</li>
                                <li>need to keep insertion order to store elements</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><b><text>Set</text></b>:
                    <ul>
                        <li><text>Duplicate</text>: doesn't allow duplicates</li>
                        <li><text>Order</text>: unordered</li>
                        <li><text>null elements</text>: one null values</li>
                        <li><text>Implementations</text>: HashSet, LinkedHashSet, TreeSet</li>
                        <li>When to use:
                            <ul>
                                <li>don't want any duplicates</li>
                            </ul>
                        </li>
                        <li>Additional Features:
                            <li>TreeSet is a SortedSet and elements stored on TreeSet can be sorted by using Comparator or Comparable in Java.</li>
                            <li>LinkedHashSet also maintains insertion order.</li>
                        </li>
                    </ul>
                </li>
                <li><b><text>Map</text></b>: 
                    <ul>
                        <li><text>Duplicate</text>: may contain duplicate values but keys are always unique</li>
                        <li><text>Order</text>: referenced by key/value pair</li>
                        <li><text>null elements</text>: Hashtable doesn't allow null key or values but HashMap allows null values and one null key (main difference between Hashtable and HashMap)</li>
                        <li><text>Implementations</text>: HashMap, LinkedHashMap, Hashtable, TreeMap</li>
                        <li>When to use:
                            <ul>
                                <li>need to store data in form of key and value</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>

            <br>
            
            <h>ArrayList Class</h><br>
            It inherits AbstractList class and implements List interface.<br>
            <br>
            <text>Important:</text>
            <ul>
                <li>Can contain duplicate elements.</li>
                <li>Java ArrayList class maintains insertion order.</li>
                <li>Allows random access because array works at the index basis.</li>
                <li>Manipulation is slow because a lot of shifting needs to be occurred if any element is removed from the array list.</li>
            </ul>
            <br>
            <img src="arraylist.jpg" style="width:70%;height:70%;"><br>
            <br>
            <b>Traversing the ArrayList</b><br>
            Two ways:<br>
            <ul>
                <li>Iterator interface</li>
                <li>for-each loop</li>
            </ul>
            
            <pre class="prettyprint">
                //Traversing list through Iterator  
                Iterator itr=list.iterator();  
                while(itr.hasNext()){  
                    System.out.println(itr.next());  
                }  

                /******************************/

                // traversing using for-each loop
                for(String obj:al)  
                    System.out.println(obj);  
                }  
            </pre>
            <br>
            <b>Complexity of <text>ArrayList</text></b>
            <ul>
                <li>add: O(1)</li>
                <li>remove: O(n)</li>
                <li>get: O(1)</li>
                <li>contains: O(n)</li>
            </ul>

            <h>Linked List</h><br>
            It inherits the AbstractList class and implements List and Deque interfaces.<br>
            <br>
            <b>Important:</b>
            <ul>
                <li>can contain duplicate elements.</li>
                <li>maintains insertion order.</li>
                <li>non synchronized.</li>
            </ul>
            <img src="linked-list.jpg" style="width:70%;height:70%;"><br>
            <br>
            <b>Complexity of <text>Linked List</text></b>
            <ul>
                <li>add: O(1)</li>
                <li>remove: O(1)</li>
                <li>get: O(n)</li>
                <li>contains: O(n)</li>
            </ul>
            <h>ArrayList vs. Linked List</h><br>
            <b><text>Search</text></b><br>
            ArrayList is faster with O(1) using get(int index)<br>
            Linked List has O(n)<br>
            <br>
            <b><text>Deletion</text></b><br>
            ArrayList has O(n) for worst case since it needs shifting if delete first element.<br>
            Linked List has O(1)<br>
            <br>
            <b><text>Insertion</text></b><br>
            ArrayList has O(n) because of shifting.<br>
            Linked List has O(1).<br>
            <br>
            <b>When to use <text>Linked List</text> and <text>ArrayList</text>:</b><br>
            * Frequent deletion and addition: <text>Linked List</text><br>
            * Frequent search operations: <text>ArrayList</text><br>
            <br>
            <h>Vector</h><br>
            Vector implements <text>List</text> interface. It implements a dynamic array just like ArrayList.<br>
            <br>
            <h>ArrayList vs. Vector</h><br>
            <ul>
                <li>Synchronization</li>
                <ul>
                    <li>ArrayList is non-synchronized which means multiple threads can work on ArrayList at the same time.</li>
                    <li>Vector is synchronized. This means only one thread can perform an operation on vector at a time.</li>
                </ul>
                <li>Performance</li>
                <ul>
                    <li>ArrayList has better performance since it is non-synchronized. Vector is thread safe.</li>
                </ul>
            </ul>

            <h>HashSet</h><br>
            It inherits the <text>AbstractSet class</text> and implements <text>Set interface</text>.<br>
            <br>
            <b>Important</b>
            <ul>
                <li>Using hashing to store elements</li>
                <li>HashSet contains unique elements only</li>
                <li>null elements are allowed in HashSet</li>
                <li>Underlying data structure for HashSet is HashTable</li>
                <li>There's no order of HashSet</li>
            </ul>
            <b>Difference between <text>Set</text> and <text>List</text></b>
            <ul>
                <li><text>List</text> is an ordered sequence of elements</li>
                <li><text>Set</text> is a distinct list of elements which is unordered</li>
            </ul>
            <b>Example declaration and implementation syntax</b><br>
            <code>
                HashSet<String> set = new HashSet<String>();<br>
                set.add("Hash");  
            </code><br>
            <br>
            <b>Traverse through HashSet</b><br>
            use next()<br>
            <br>
            <b>Complexity</b>
            <ul>
                <li>add: O(1)</li>
                <li>contains: O(1)</li>
            </ul>

            <h>LinkedHashSet</h><br>
            LinkedHashSet class is a Hash table and Linked list implementation of the set interface. It inherits HashSet class and implements Set interface.<br>
            <br>
            <b>Important</b>
            <ul>
                <li>Contains unique elements only like HashSet</li>
                <li>Provides all optional set operations, and permits null elements</li>
                <li>Maintains insertion order</li>
            </ul>

            <b>Complexity</b>
            <ul>
                <li>add: O(1)</li>
                <li>contains: O(1)</li>
            </ul>

            <h>TreeSet</h><br>
            TreeSet class implements the Set interface that uses a tree for storage. 
            It inherits AbstractSet class and implements NavigableSet interface. 
            The objects of TreeSet class are stored in ascending order.
            <br><br>
            <b>Important</b>
            <ul>
                <li>Contains unique elements only like HashSet</li>
                <li>Access and retrieval times are quiet fast</li>
                <li>Maintains ascending order</li>
            </ul>

            <b>Complexity</b>
            <ul>
                <li>add: O(logn)</li>
                <li>contains: O(logn)</li>
            </ul>

            <h>Queue</h><br>
            <ul>
                <li>FIFO: enqueue ->| ||||| |-> dequeue</li>
            </ul>
            <b>Complexity</b><br>
            <ul>
                <li>enqueue(), dequeue(), isFull(), isEmpty(), front() and rear() is O(1)</li>
            </ul>

            <h>Priority Queue</h><br>
            The PriorityQueue class provides the facility of using queue. 
            But it does not orders the elements in FIFO manner. It inherits AbstractQueue class.<br>
            An unbounded priority queue based on a priority heap.<br>
            <br>
            <b>Important</b>
            <ul>
                <li>The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.</li>
                <li>A priority queue does not permit null elements.</li>
                <li>not synchronized</li>
            </ul>

            <b>Methods and Complexity</b><br>
            <ul>
                <li><text>boolean offer():</text> same as add() - O(logn)</li>
                <li><text>poll():</text> remove head of queue and return - O(logn)</li>
                <li><text>peek():</text> O(1)</li>
            </ul>

            <h>Deque Interface</h><br>
            Deque is a Queue in which you can add and remove elements from both sides.<br>
            It has two implementations: <text>LinkedList</text> and <text>ArrayDeque</text>.<br>
            <br>
            <b>Methods of Deque Interface</b>
            <ul>
                <li>void addFirst()</li>
                <li>void addLast()</li>
                <li>boolean contains()</li>
                <li>getFirst()</li>
                <li>getLast()</li>
                <li>pollFirst()</li>
                <li>pollLast()</li>
                <li>peekFirst()</li>
                <li>peekLast()</li>
                <li>size()</li>
            </ul>

            <h>ArrayDeque Class</h><br>
            The ArrayDeque class provides the facility of using deque and resizable-array. 
            It inherits AbstractCollection class and implements the Deque interface.<br>
            <br>
            <b>Important</b>
            <ul>
                <li>can add or remove elements from both sides</li>
                <li>Null elements are not allowed in the ArrayDeque</li>
                <li>Not thread safe</li>
                <li>no capacity restrictions</li>
                <li>ArrayDeque is faster than LinkedList and Stack</li>
            </ul>
       </div>

    </body>
</html>
